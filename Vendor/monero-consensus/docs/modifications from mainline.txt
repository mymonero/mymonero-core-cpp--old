* account.cpp had to be modified in place - didn't make sense to edit monero_legacy16B_key.* to e.g. subclass account_base

	* .h
    ```
    crypto::secret_key generate(const crypto::secret_key& recovery_key = crypto::secret_key(), bool recover = false, bool two_random = false, bool from_legacy16B_lw_seed = false);
    ```

	* .cpp
	```
	crypto::secret_key account_base::generate(const crypto::secret_key& recovery_key, bool recover, bool two_random, bool from_legacy16B_lw_seed)

	keccak((uint8_t *)&(from_legacy16B_lw_seed ? first : m_keys.m_spend_secret_key), sizeof(crypto::secret_key), (uint8_t *)&second, sizeof(crypto::secret_key));
	```

* generate() calls extracted from wallet2 and customized in wallet3_base to remove persistence - bc wallet2 probably wont be able to deal with empty wallet_filepath

* wallet2: private -> protected to allow subclassing - FIXME: is this safe?

* bool wallet2::is_output_blackballed(const crypto::public_key &output) const
{
	return false;
}


* remove create_transactions_2 call to light_wallet_get_unspent_outs - and remove all light_wallet_get*, login, import_request methods

* use_fork_rules
	1. add for lightwallet case
	// TODO: implement.. need to have the latest lightwallet blockchain height and look up earliest_height for the version requested.. then call monero_fork_rules function
	//
	// This is all temporary:
	if (version >= get_bulletproof_fork()) {
		return false;
	}
	return true;

	2. redact remaining rpc calls

* need to fix balance / unlocked_balance
		uint64_t light_wallet3::balance(uint32_t index_major) const
		{
			return m_light_wallet_total_received - m_light_wallet_total_sent;
		}
		uint64_t light_wallet3::unlocked_balance(uint32_t index_major) const
		{
			return (m_light_wallet_total_received - m_light_wallet_total_sent) - m_light_wallet_locked_balance; // FIXME: verify correctness
		}
		bool light_wallet3::use_fork_rules(uint8_t version, int64_t early_blocks) const
		{
			// TODO: implement.. need to have the latest lightwallet blockchain height and look up earliest_height for the version requested.. then call monero_fork_rules function
			//
			// This is all temporary:
			if (version >= monero_fork_rules::get_bulletproof_fork()) {
				return false;
			}
			return true;
		}

*


	bool wallet3_base::use_fork_rules(uint8_t version, int64_t early_blocks) const
	{
		THROW_WALLET_EXCEPTION_IF(true, error::wallet_internal_error, "Override and implement use_fork_rules");

		return false;
	}

* remove process_outgoing



* TODO: make get_outs overridable and synchronously get lightwallet outs



* miner.cpp - redact everything except `find_nonce_for_given_block`